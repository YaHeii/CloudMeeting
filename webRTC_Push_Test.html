<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRS WebRTC Push Test</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            padding: 16px;
        }

        #debugLog {
            white-space: pre-wrap;
            background: #111;
            color: #dcdcdc;
            padding: 8px;
            max-height: 300px;
            overflow: auto;
            border-radius: 4px;
        }

        video {
            background: #000;
            border-radius: 4px;
        }

        button {
            margin-top: 8px;
        }

        code {
            background: #f3f3f3;
            padding: 2px 4px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>SRS WebRTC 推流测试</h1>
    <video id="localVideo" width="320" height="240" autoplay muted></video>
    <br>
    <button id="startBtn">开始推流</button>
    <button id="stopBtn" disabled>停止推流</button>
    <p>流地址: <code id="streamUrl"></code></p>

    <h3>调试日志</h3>
    <pre id="debugLog"></pre>
    <button id="saveBtn">保存日志</button>
    <button id="deleteBtn">删除日志</button>

    <script>
        // 配置
        const srsServerIp = "10.0.0.10";
        const streamName = "teststream";
        const streamUrl = `webrtc://${srsServerIp}/live/${streamName}`;

        // 页面元素
        const videoElement = document.getElementById('localVideo');
        const streamUrlElement = document.getElementById('streamUrl');
        const debugLog = document.getElementById('debugLog');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const saveBtn = document.getElementById('saveBtn');
        const deleteBtn = document.getElementById('deleteBtn');

        streamUrlElement.innerText = streamUrl;

        // 全局资源引用，便于停止/清理
        let pc = null;
        let localStream = null;

        // 日志函数：同时输出到控制台与页面
        function log(level, ...args) {
        const time = new Date().toISOString();
        const text = `[${time}] ${level}: ${args.map(a => {
        try { return typeof a === 'string' ? a : (JSON.stringify(a)); }
        catch (e) { return String(a); }
        }).join(' ')}`;
        // 控制台
        if (level === 'ERROR') console.error(...args);
        else if (level === 'WARN') console.warn(...args);
        else console.log(...args);
        // 页面
        debugLog.textContent += text + '\n';
        debugLog.scrollTop = debugLog.scrollHeight;
        }

        // 保存调试日志到文件
        function saveDebugLog() {
        try {
        const text = debugLog.textContent || '';
        const now = new Date();
        const pad = (n) => String(n).padStart(2, '0');
        const filename = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}.txt`;
        const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        log('INFO', '调试日志已保存为', filename);
        } catch (e) {
        log('ERROR', '保存调试日志失败', e);
        alert('保存日志失败，请检查控制台。');
        }
        }
        function deleteDebugLog() {
        try {
        // 检查 debugLog 节点和内容
        if (!debugLog || typeof debugLog.textContent === 'undefined') {
        console.warn('deleteDebugLog: debugLog 元素不存在或不支持 textContent');
        return;
        }

        // 如果日志为空，则记录并返回
        if (!debugLog.textContent || debugLog.textContent.trim().length === 0) {
        log('WARN', '调试日志为空，无需删除');
        return;
        }

        // 确认删除
        const ok = confirm('确定要删除调试日志吗？此操作不可撤销。');
        if (!ok) {
        log('INFO', '用户取消了删除调试日志的操作');
        return;
        }

        // 清空日志
        debugLog.textContent = '';

        // 记录已删除（会在清空后写入一条新日志）
        log('INFO', '调试日志已删除（新日志将从此处开始记录）');
        } catch (e) {
        log('ERROR', '删除调试日志失败', e);
        alert('删除日志失败，请查看控制台。');
        }
        }

        saveBtn.addEventListener('click', saveDebugLog);
        deleteBtn.addEventListener('click', deleteDebugLog);

        // 带超时的 fetch
        async function fetchWithTimeout(url, options = {}, timeoutMs = 15000) {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeoutMs);
        try {
        const res = await fetch(url, { ...options, signal: controller.signal });
        clearTimeout(id);
        return res;
        } catch (err) {
        clearTimeout(id);
        throw err;
        }
        }

        // 清理函数：关闭 pc、停止本地流
        function cleanup() {
        if (pc) {
        try { pc.close(); log('WARN', 'PeerConnection closed'); } catch (e) { log('ERROR', '关闭 PeerConnection失败', e); }
        pc = null;
        }
        if (localStream) {
        localStream.getTracks().forEach(t => {
        try { t.stop(); } catch (e) { /* ignore */ }
        });
        localStream = null;
        videoElement.srcObject = null;
        log('WARN', '本地媒体流已停止');
        }
        startBtn.disabled = false;
        stopBtn.disabled = true;
        }

        // 停止按钮处理
        stopBtn.addEventListener('click', () => {
        log('WARN', '手动停止推流');
        cleanup();
        });

        startBtn.addEventListener('click', startPublish);

        async function startPublish() {
        startBtn.disabled = true;
        stopBtn.disabled = false;
        log('INFO', '开始推流流程，目标 SRS:', streamUrl);

        pc = new RTCPeerConnection();

        // 事件处理 - 记录更多连接状态信息
        pc.addEventListener('icecandidate', (ev) => {
        if (ev.candidate) log('INFO', '产生 ICE candidate', ev.candidate);
        else log('INFO', 'ICE candidate 已结束（null 表示完成）');
        });

        pc.addEventListener('connectionstatechange', () => {
        log('INFO', 'connectionState:', pc.connectionState);
        });

        pc.addEventListener('iceconnectionstatechange', () => {
        log('INFO', 'iceConnectionState:', pc.iceConnectionState);
        if (pc.iceConnectionState === 'failed') {
        log('ERROR', 'ICE连接失败，建议检查网络或 TURN 配置');
        }
        });

        pc.addEventListener('track', (ev) => {
        log('INFO', '收到远端 track', ev);
        });

        pc.addEventListener('negotiationneeded', () => {
        log('INFO', 'negotiationneeded 触发');
        });

        try {
        // 1. 获取本地媒体
        try {
        localStream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: { width: 640, height: 480 }
        });
        videoElement.srcObject = localStream;
        log('INFO', '获取到本地媒体流', {
        tracks: localStream.getTracks().map(t => ({ kind: t.kind, enabled: t.enabled }))
        });
        } catch (err) {
        log('ERROR', 'getUserMedia 失败:', err.name || err.message || err);
        if (err && err.name === 'NotAllowedError') {
        alert('访问摄像头/麦克风被拒绝，请允许权限后重试。');
        } else if (err && err.name === 'NotFoundError') {
        alert('未找到摄像头或麦克风设备，请检查硬件。');
        } else {
        alert('获取本地媒体失败，请查看日志。');
        }
        cleanup();
        return;
        }

        // 2. 添加轨道
        try {
        localStream.getTracks().forEach(track => {
        pc.addTrack(track, localStream);
        log('INFO', '已向 PeerConnection 添加轨道', { kind: track.kind, id: track.id });
        });
        } catch (err) {
        log('ERROR', 'addTrack 失败', err);
        cleanup();
        return;
        }

        // 3. 创建 Offer 并设置本地描述
        let offer;
        try {
        offer = await pc.createOffer();
        log('INFO', '创建 Offer SDP 长度:', offer.sdp ? offer.sdp.length : 0);
        } catch (err) {
        log('ERROR', 'createOffer 失败', err);
        cleanup();
        return;
        }

        try {
        await pc.setLocalDescription(offer);
        log('INFO', '已设置本地描述 (offer)');
        } catch (err) {
        log('ERROR', 'setLocalDescription(offer) 失败', err);
        cleanup();
        return;
        }

        // 4. 发送信令到 SRS（带超时、HTTP 状态检查、JSON 解析错误处理）
        const publishUrl = `http://${srsServerIp}:1985/rtc/v1/publish/`;
        log('INFO', '发送 Offer 到 SRS URL:', publishUrl);

        let response;
        try {
        response = await fetchWithTimeout(publishUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
        sdp: offer.sdp,
        streamurl: streamUrl
        })
        }, 15000);
        } catch (err) {
        if (err.name === 'AbortError') {
        log('ERROR', '请求 SRS 超时或被中止:', err);
        alert('与 SRS 的信令请求超时，请检查网络或 SRS 是否可达。');
        } else {
        log('ERROR', '向 SRS 发送请求失败:', err);
        alert('发送 Offer 到 SRS 失败，请查看控制台日志。');
        }
        cleanup();
        return;
        }

        // 检查 HTTP 状态
        if (!response.ok) {
        let bodyText = '';
        try { bodyText = await response.text(); } catch (e) { bodyText = '<无法读取响应体>'; }
        log('ERROR', `SRS 返回 HTTP ${response.status} ${response.statusText}`, bodyText);
        alert(`SRS 返回错误 HTTP ${response.status}，请查看日志获取更多信息。`);
        cleanup();
        return;
        }

        // 解析 JSON
        let data;
        try {
        data = await response.json();
        log('INFO', '从 SRS 收到响应 JSON', data);
        } catch (err) {
        let raw = '';
        try { raw = await response.text(); } catch (e) { raw = '<无法读取原始响应>'; }
        log('ERROR', '解析 SRS 响应为 JSON 失败', err, '原始响应:', raw);
        alert('解析 SRS 响应失败，请查看日志。');
        cleanup();
        return;
        }

        // 验证响应
        if (typeof data.code === 'undefined' || data.code !== 0) {
        log('ERROR', 'SRS 返回错误 code 或业务错误', data);
        alert('SRS 返回了错误，请查看日志中的详细信息。');
        cleanup();
        return;
        }
        if (!data.sdp) {
        log('ERROR', 'SRS 响应缺少 sdp 字段', data);
        alert('SRS 响应缺少 SDP，推流失败。');
        cleanup();
        return;
        }

        // 5. 设置远端 SDP
        try {
        await pc.setRemoteDescription({ type: 'answer', sdp: data.sdp });
        log('INFO', '已设置远端描述 (answer)');
        } catch (err) {
        log('ERROR', 'setRemoteDescription(answer) 失败', err);
        // 记录接收到的 SDP（部分浏览器可能有格式问题）
        log('WARN', '接收到的 SDP（前1000 字符）:', data.sdp.slice ? data.sdp.slice(0, 1000) : data.sdp);
        alert('设置远端 SDP 失败，请查看日志。');
        cleanup();
        return;
        }

        log('INFO', '推流成功，已连接到 SRS，建议在播放器中查看流。');
        alert('推流成功！请在播放器中查看。');

        } catch (err) {
        log('ERROR', '未捕获的异常:', err);
        alert('发生未知错误，请查看调试日志。');
        cleanup();
        }
        }
    </script>
</body>
</html>